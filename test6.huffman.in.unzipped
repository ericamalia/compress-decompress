byte is: 40
byte is: 41
byte is: 119
byte is: 60
byte is: 45
byte is: 67
byte is: 79
byte is: 101
byte is: 121
byte is: 103
byte is: 46
byte is: 50
byte is: 61
byte is: 110
byte is: 35
byte is: 32
byte is: 68
byte is: 71
byte is: 86
byte is: 120
byte is: 82
byte is: 85
byte is: 102
byte is: 115
byte is: 117
byte is: 123
byte is: 125
byte is: 109
byte is: 114
byte is: 95
byte is: 37
byte is: 47
byte is: 80
byte is: 118
byte is: 91
byte is: 93
byte is: 64
byte is: 116
byte is: 105
byte is: 49
byte is: 73
byte is: 78
byte is: 100
byte is: 99
byte is: 42
byte is: 52
byte is: 53
byte is: 55
byte is: 54
byte is: 56
byte is: 57
byte is: 63
byte is: 62
byte is: 65
byte is: 81
byte is: 88
byte is: 94
byte is: 256
byte is: 124
byte is: 58
byte is: 72
byte is: 10
byte is: 108
byte is: 111
byte is: 76
byte is: 83
byte is: 84
byte is: 107
byte is: 43
byte is: 70
byte is: 34
byte is: 104
byte is: 112
byte is: 44
byte is: 48
byte is: 92
byte is: 126
byte is: 33
byte is: 113
byte is: 98
byte is: 69
byte is: 97
byte is: 59
byte is: 36
#!/usr/bin/perl -w
# $Id: test6.huffman.in,v 1.1 2019-02-01 17:04:29-08 - - $
#
# Perl solution to the cmps012b Huffman Coding assignment.
#

################################################################

package Tree;

sub new{
   my( $class, $char, $count, @child ) = @_;
   my( $this ) = { CHAR=>$char, COUNT=>$count, CHILD=>[ @child ] };
   return bless $this, $class;
};

sub compare{
   my( $this, $other ) = @_;
   return $$this{COUNT} <=> $$other{COUNT}
       || $$this{CHAR}  <=> $$other{CHAR};
};

################################################################

package Priority_Queue;

sub new{
   my( $class ) = @_;
   my( $this ) = [];
   return bless $this, $class;
};

sub insert{
   my( $this, $node ) = @_;
   my( $parent, $child );
   push @$this, $node;
   for( $child = @$this; $parent = $child >> 1; $child = $parent ){
      last if $$this[$parent-1]->compare( $$this[$child-1] ) < 0;
      @$this[ $parent-1, $child-1 ] = @$this[ $child-1, $parent-1 ];
   };
};

sub remove{
   my( $this ) = @_;
   my $result = shift @$this;
   if( @$this ){
      my( $parent, $child );
      unshift @$this, pop @$this;
      for( $parent = 1; ; $parent = $child ){
         $child = $parent << 1;
         last if $child > @$this;
         $child++ if $child < @$this
                 and $$this[$child]->compare( $$this[$child-1] ) < 0;
         last if $$this[$parent-1]->compare( $$this[$child-1] ) < 0;
         @$this[ $parent-1, $child-1 ] = @$this[ $child-1, $parent-1 ];
      };
   };
   return $result;
};

################################################################

package main;
use POSIX qw( isgraph );
$EOFCODE = 256;

sub encode{
   my( $tree, $bits ) = @_;
   if( not defined $bits ){
      local( $codes ) = {};
      encode( $tree, "" ) if defined $tree;
      return $codes;
   }else{
      if( @{$$tree{CHILD}} ){
         map { encode( ${$$tree{CHILD}}[$_], "$bits$_" ) } (0,1);
      }else{
         $$codes{$$tree{CHAR}} = { COUNT=>$$tree{COUNT}, CODE=>$bits };
      };
   };
};

sub huffman(**){
   my( $infile, $outfile ) = @_;
   my( %freq_table, $line, @pair, $node0, $node1 );

   map { $freq_table{ ord $_ }++ } split m//, $line
         while defined( $line = <$infile> );
   $freq_table{ $EOFCODE } = 0;

   my $queue = new Priority_Queue;
   insert $queue( new Tree @pair ) while @pair = each %freq_table;

   for(;;){
      $node0 = remove $queue;
      $node1 = remove $queue;
      last unless defined $node1;
      insert $queue( new Tree $$node0{CHAR},
            $$node0{COUNT} + $$node1{COUNT}, $node0, $node1 );
   };
   my $codes_vector = encode $node0;

   for $ordchar( sort { $a <=> $b } keys %$codes_vector ){
      my $char = chr $ordchar;
      my $charstr = $ordchar == $EOFCODE ? "EOF"
                  : isgraph( $char ) ? $char
                  : sprintf( "\\x%02X", $ordchar );
      printf $outfile "%4s %8d %s\n", $charstr,
             @{$$codes_vector{$ordchar}}{ COUNT, CODE };
   };

};

( $Program_Name = $0 ) =~ s{.*/}{};
$Exit_Status = 0;

if( not @ARGV ){
   huffman STDIN, STDOUT;
}else{
   while( @ARGV ){
      my( $infilename ) = shift @ARGV;
      my( $outfilename ) = "$infilename.coding" =~ m{([^/]*$)};
      if( not open( INFILE, "<$infilename" )){
         print STDERR "$Program_Name: $infilename: $!\n";
         $Exit_Status = 1;
      }elsif( not open( OUTFILE, ">$outfilename" )){
         print STDERR "$Program_Name: $outfilename: $!\n";
         $Exit_Status = 1;
      }else{
         huffman INFILE, OUTFILE;
      };
      close INFILE;
      close OUTFILE;
   };
};
exit $Exit_Status;

